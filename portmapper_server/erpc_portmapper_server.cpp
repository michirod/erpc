/*
 * Generated by erpcgen 1.4.0 on Wed May  3 17:25:28 2017.
 *
 * AUTOGENERATED - DO NOT EDIT
 */

#include "erpc_portmapper_server.h"
#include <new>
#include "transport.h"
#include "erpc_transport_setup.h"
#include "erpc_port.h"

using namespace erpc;
#if !(__embedded_cplusplus)
using namespace std;
#endif

// Constant variable definitions
const pm_addr_port portmapper_port = 111;

//! @brief Function to read struct pm_entry
static int32_t read_pm_entry_struct(erpc::Codec * codec, pm_entry * data);

// Read struct pm_entry function implementation
static int32_t read_pm_entry_struct(erpc::Codec * codec, pm_entry * data)
{
    int32_t enum_tmp_local;
    erpc_status_t err = codec->startReadStruct();
    if (!err)
    {
        err = codec->read(&data->program_id);
    }

    if (!err)
    {
        err = codec->read(&enum_tmp_local);
        if (!err)
        {
            data->protocol = static_cast<pm_protocols>(enum_tmp_local);
        }
    }

    if (!err)
    {
        err = codec->read(&data->core_id);
    }

    if (!err)
    {
        err = codec->read(&data->port);
    }

    if (!err)
    {
        err = codec->endReadStruct();
    }
    return err;
}

//! @brief Function to write struct pm_entry
static int32_t write_pm_entry_struct(erpc::Codec * codec, const pm_entry * data);

//! @brief Function to write struct list_0_t
static int32_t write_list_0_t_struct(erpc::Codec * codec, const list_0_t * data);

// Write struct pm_entry function implementation
static int32_t write_pm_entry_struct(erpc::Codec * codec, const pm_entry * data)
{
    erpc_status_t err = codec->startWriteStruct();
    if (!err)
    {
        err = codec->write(data->program_id);
    }

    if (!err)
    {
        err = codec->write(static_cast<int32_t>(data->protocol));
    }

    if (!err)
    {
        err = codec->write(data->core_id);
    }

    if (!err)
    {
        err = codec->write(data->port);
    }

    if (!err)
    {
        err = codec->endWriteStruct();
    }
    return err;
}

// Write struct list_0_t function implementation
static int32_t write_list_0_t_struct(erpc::Codec * codec, const list_0_t * data)
{
    erpc_status_t err = codec->startWriteStruct();
    if (!err)
    {
        if (data->elementsCount > 0 && data->elements)
        {
            err = codec->startWriteList(data->elementsCount);
            for (uint32_t listCount = 0; listCount < data->elementsCount; ++listCount)
            {
                if (!err)
                {
                    err = write_pm_entry_struct(codec, &(data->elements[listCount]));
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            err = codec->startWriteList(0);
        }
        if (!err)
        {
            err = codec->endWriteList();
        }
    }

    if (!err)
    {
        err = codec->endWriteStruct();
    }
    return err;
}

//! @brief Function to free space allocated inside struct list_0_t
static void free_list_0_t_struct(list_0_t * data);

// Free space allocated inside struct list_0_t function implementation
static void free_list_0_t_struct(list_0_t * data)
{
    if (data->elements)
    {
        erpc_free(data->elements);
    }
}


// Call the correct server shim based on method unique ID.
erpc_status_t portmapper_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory, Transport *transport)
{
    switch (methodId)
    {
        case kportmapper_register_service_id:
            return register_service_shim(codec, messageFactory, transport, sequence);

        case kportmapper_register_entry_id:
            return register_entry_shim(codec, messageFactory, transport, sequence);

        case kportmapper_unregister_service_id:
            return unregister_service_shim(codec, messageFactory, transport, sequence);

        case kportmapper_unregister_entry_id:
            return unregister_entry_shim(codec, messageFactory, transport, sequence);

        case kportmapper_lookup_id:
            return lookup_shim(codec, messageFactory, transport, sequence);

        case kportmapper_lookup_proto_id:
            return lookup_proto_shim(codec, messageFactory, transport, sequence);

        case kportmapper_dump_id:
            return dump_shim(codec, messageFactory, transport, sequence);

        default:
            return kErpcStatus_InvalidArgument;
    }
}

// Server shim for register_service of portmapper interface.
erpc_status_t portmapper_service::register_service_shim(Codec * codec, MessageBufferFactory *messageFactory, Transport *inner_transport, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    erpc_transport_t transport = reinterpret_cast<erpc_transport_t>(inner_transport);

    uint32_t program_id;
    pm_protocols protocol;
    uint16_t port;
    int32_t enum_tmp_local;

    // startReadMessage() was already called before this shim was invoked.

    if (!err)
    {
        err = codec->read(&program_id);
    }

    if (!err)
    {
        err = codec->read(&enum_tmp_local);
        if (!err)
        {
            protocol = static_cast<pm_protocols>(enum_tmp_local);
        }
    }

    if (!err)
    {
        err = codec->read(&port);
    }

    if (!err)
    {
        err = codec->endReadMessage();
    }

    // Invoke the actual served function.
    bool result;
    if (!err)
    {
        result = register_service(transport, program_id, protocol, port);
    }

    // preparing MessageBuffer for serializing data
    if (!err)
    {
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    // preparing codec for serializing data
    codec->reset();

    // Build response message.
    if (!err)
    {
        err = codec->startWriteMessage(kReplyMessage, kportmapper_service_id, kportmapper_register_service_id, sequence);
    }

    if (!err)
    {
        err = codec->write(result);
    }

    if (!err)
    {
        err = codec->endWriteMessage();
    }

    return err;
}

// Server shim for register_entry of portmapper interface.
erpc_status_t portmapper_service::register_entry_shim(Codec * codec, MessageBufferFactory *messageFactory, Transport *inner_transport, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    erpc_transport_t transport = reinterpret_cast<erpc_transport_t>(inner_transport);

    pm_entry *entry = NULL;
    entry = (pm_entry *) erpc_malloc(sizeof(pm_entry));
    if (entry == NULL)
    {
        err = kErpcStatus_MemoryError;
    }

    // startReadMessage() was already called before this shim was invoked.

    if (!err)
    {
        err = read_pm_entry_struct(codec, entry);
    }

    if (!err)
    {
        err = codec->endReadMessage();
    }

    // Invoke the actual served function.
    bool result;
    if (!err)
    {
        result = register_entry(transport, entry);
    }

    // preparing MessageBuffer for serializing data
    if (!err)
    {
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    // preparing codec for serializing data
    codec->reset();

    // Build response message.
    if (!err)
    {
        err = codec->startWriteMessage(kReplyMessage, kportmapper_service_id, kportmapper_register_entry_id, sequence);
    }

    if (!err)
    {
        err = codec->write(result);
    }

    if (!err)
    {
        err = codec->endWriteMessage();
    }

    if (entry)
    {
        erpc_free(entry);
    }

    return err;
}

// Server shim for unregister_service of portmapper interface.
erpc_status_t portmapper_service::unregister_service_shim(Codec * codec, MessageBufferFactory *messageFactory, Transport *inner_transport, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    erpc_transport_t transport = reinterpret_cast<erpc_transport_t>(inner_transport);

    uint32_t program_id;
    pm_protocols protocol;
    uint16_t port;
    int32_t enum_tmp_local;

    // startReadMessage() was already called before this shim was invoked.

    if (!err)
    {
        err = codec->read(&program_id);
    }

    if (!err)
    {
        err = codec->read(&enum_tmp_local);
        if (!err)
        {
            protocol = static_cast<pm_protocols>(enum_tmp_local);
        }
    }

    if (!err)
    {
        err = codec->read(&port);
    }

    if (!err)
    {
        err = codec->endReadMessage();
    }

    // Invoke the actual served function.
    bool result;
    if (!err)
    {
        result = unregister_service(transport, program_id, protocol, port);
    }

    // preparing MessageBuffer for serializing data
    if (!err)
    {
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    // preparing codec for serializing data
    codec->reset();

    // Build response message.
    if (!err)
    {
        err = codec->startWriteMessage(kReplyMessage, kportmapper_service_id, kportmapper_unregister_service_id, sequence);
    }

    if (!err)
    {
        err = codec->write(result);
    }

    if (!err)
    {
        err = codec->endWriteMessage();
    }

    return err;
}

// Server shim for unregister_entry of portmapper interface.
erpc_status_t portmapper_service::unregister_entry_shim(Codec * codec, MessageBufferFactory *messageFactory, Transport *inner_transport, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    erpc_transport_t transport = reinterpret_cast<erpc_transport_t>(inner_transport);

    pm_entry *entry = NULL;
    entry = (pm_entry *) erpc_malloc(sizeof(pm_entry));
    if (entry == NULL)
    {
        err = kErpcStatus_MemoryError;
    }

    // startReadMessage() was already called before this shim was invoked.

    if (!err)
    {
        err = read_pm_entry_struct(codec, entry);
    }

    if (!err)
    {
        err = codec->endReadMessage();
    }

    // Invoke the actual served function.
    bool result;
    if (!err)
    {
        result = unregister_entry(transport, entry);
    }

    // preparing MessageBuffer for serializing data
    if (!err)
    {
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    // preparing codec for serializing data
    codec->reset();

    // Build response message.
    if (!err)
    {
        err = codec->startWriteMessage(kReplyMessage, kportmapper_service_id, kportmapper_unregister_entry_id, sequence);
    }

    if (!err)
    {
        err = codec->write(result);
    }

    if (!err)
    {
        err = codec->endWriteMessage();
    }

    if (entry)
    {
        erpc_free(entry);
    }

    return err;
}

// Server shim for lookup of portmapper interface.
erpc_status_t portmapper_service::lookup_shim(Codec * codec, MessageBufferFactory *messageFactory, Transport *inner_transport, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    erpc_transport_t transport = reinterpret_cast<erpc_transport_t>(inner_transport);

    uint32_t program_id;

    // startReadMessage() was already called before this shim was invoked.

    if (!err)
    {
        err = codec->read(&program_id);
    }

    if (!err)
    {
        err = codec->endReadMessage();
    }

    // Invoke the actual served function.
    pm_entry_list * result = NULL;
    if (!err)
    {
        result = lookup(transport, program_id);
    }

    // preparing MessageBuffer for serializing data
    if (!err)
    {
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    // preparing codec for serializing data
    codec->reset();

    // Build response message.
    if (!err)
    {
        err = codec->startWriteMessage(kReplyMessage, kportmapper_service_id, kportmapper_lookup_id, sequence);
    }

    if (!err)
    {
        err = write_list_0_t_struct(codec, result);
    }

    if (!err)
    {
        err = codec->endWriteMessage();
    }

    if (result)
    {
        free_list_0_t_struct(result);
    }
    if (result)
    {
        erpc_free(result);
    }
    return err;
}

// Server shim for lookup_proto of portmapper interface.
erpc_status_t portmapper_service::lookup_proto_shim(Codec * codec, MessageBufferFactory *messageFactory, Transport *inner_transport, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    erpc_transport_t transport = reinterpret_cast<erpc_transport_t>(inner_transport);

    uint32_t program_id;
    pm_protocols protocol;
    int32_t enum_tmp_local;

    // startReadMessage() was already called before this shim was invoked.

    if (!err)
    {
        err = codec->read(&program_id);
    }

    if (!err)
    {
        err = codec->read(&enum_tmp_local);
        if (!err)
        {
            protocol = static_cast<pm_protocols>(enum_tmp_local);
        }
    }

    if (!err)
    {
        err = codec->endReadMessage();
    }

    // Invoke the actual served function.
    pm_entry_list * result = NULL;
    if (!err)
    {
        result = lookup_proto(transport, program_id, protocol);
    }

    // preparing MessageBuffer for serializing data
    if (!err)
    {
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    // preparing codec for serializing data
    codec->reset();

    // Build response message.
    if (!err)
    {
        err = codec->startWriteMessage(kReplyMessage, kportmapper_service_id, kportmapper_lookup_proto_id, sequence);
    }

    if (!err)
    {
        err = write_list_0_t_struct(codec, result);
    }

    if (!err)
    {
        err = codec->endWriteMessage();
    }

    if (result)
    {
        free_list_0_t_struct(result);
    }
    if (result)
    {
        erpc_free(result);
    }
    return err;
}

// Server shim for dump of portmapper interface.
erpc_status_t portmapper_service::dump_shim(Codec * codec, MessageBufferFactory *messageFactory, Transport *inner_transport, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    erpc_transport_t transport = reinterpret_cast<erpc_transport_t>(inner_transport);

    // startReadMessage() was already called before this shim was invoked.

    if (!err)
    {
        err = codec->endReadMessage();
    }

    // Invoke the actual served function.
    if (!err)
    {
        dump(transport);
    }

    return err;
}
erpc_service_t create_portmapper_service()
{
    return new (nothrow) portmapper_service();
}
